/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.1
 * source: sync/sync.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace sync {
    export class Null extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): Null {
            const message = new Null({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Null {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Null();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Null {
            return Null.deserialize(bytes);
        }
    }
    export class Status extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            succeeded?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("succeeded" in data && data.succeeded != undefined) {
                    this.succeeded = data.succeeded;
                }
            }
        }
        get succeeded() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set succeeded(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            succeeded?: boolean;
        }): Status {
            const message = new Status({});
            if (data.succeeded != null) {
                message.succeeded = data.succeeded;
            }
            return message;
        }
        toObject() {
            const data: {
                succeeded?: boolean;
            } = {};
            if (this.succeeded != null) {
                data.succeeded = this.succeeded;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.succeeded != false)
                writer.writeBool(1, this.succeeded);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Status {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Status();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.succeeded = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Status {
            return Status.deserialize(bytes);
        }
    }
    export class TransactionId extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transaction_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction_id" in data && data.transaction_id != undefined) {
                    this.transaction_id = data.transaction_id;
                }
            }
        }
        get transaction_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set transaction_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            transaction_id?: string;
        }): TransactionId {
            const message = new TransactionId({});
            if (data.transaction_id != null) {
                message.transaction_id = data.transaction_id;
            }
            return message;
        }
        toObject() {
            const data: {
                transaction_id?: string;
            } = {};
            if (this.transaction_id != null) {
                data.transaction_id = this.transaction_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transaction_id.length)
                writer.writeString(1, this.transaction_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TransactionId {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TransactionId();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.transaction_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TransactionId {
            return TransactionId.deserialize(bytes);
        }
    }
    export class Strategy extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            strategy?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("strategy" in data && data.strategy != undefined) {
                    this.strategy = data.strategy;
                }
            }
        }
        get strategy() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set strategy(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            strategy?: string;
        }): Strategy {
            const message = new Strategy({});
            if (data.strategy != null) {
                message.strategy = data.strategy;
            }
            return message;
        }
        toObject() {
            const data: {
                strategy?: string;
            } = {};
            if (this.strategy != null) {
                data.strategy = this.strategy;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.strategy.length)
                writer.writeString(1, this.strategy);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Strategy {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Strategy();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.strategy = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Strategy {
            return Strategy.deserialize(bytes);
        }
    }
    export class Interval extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            interval?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("interval" in data && data.interval != undefined) {
                    this.interval = data.interval;
                }
            }
        }
        get interval() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set interval(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            interval?: string;
        }): Interval {
            const message = new Interval({});
            if (data.interval != null) {
                message.interval = data.interval;
            }
            return message;
        }
        toObject() {
            const data: {
                interval?: string;
            } = {};
            if (this.interval != null) {
                data.interval = this.interval;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.interval.length)
                writer.writeString(1, this.interval);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Interval {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Interval();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.interval = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Interval {
            return Interval.deserialize(bytes);
        }
    }
    export class TransactionIdList extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transaction_list?: TransactionId[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction_list" in data && data.transaction_list != undefined) {
                    this.transaction_list = data.transaction_list;
                }
            }
        }
        get transaction_list() {
            return pb_1.Message.getRepeatedWrapperField(this, TransactionId, 1) as TransactionId[];
        }
        set transaction_list(value: TransactionId[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            transaction_list?: ReturnType<typeof TransactionId.prototype.toObject>[];
        }): TransactionIdList {
            const message = new TransactionIdList({});
            if (data.transaction_list != null) {
                message.transaction_list = data.transaction_list.map(item => TransactionId.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                transaction_list?: ReturnType<typeof TransactionId.prototype.toObject>[];
            } = {};
            if (this.transaction_list != null) {
                data.transaction_list = this.transaction_list.map((item: TransactionId) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transaction_list.length)
                writer.writeRepeatedMessage(1, this.transaction_list, (item: TransactionId) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TransactionIdList {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TransactionIdList();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.transaction_list, () => pb_1.Message.addToRepeatedWrapperField(message, 1, TransactionId.deserialize(reader), TransactionId));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TransactionIdList {
            return TransactionIdList.deserialize(bytes);
        }
    }
    export class Error extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            error?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get error() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set error(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            error?: string;
        }): Error {
            const message = new Error({});
            if (data.error != null) {
                message.error = data.error;
            }
            return message;
        }
        toObject() {
            const data: {
                error?: string;
            } = {};
            if (this.error != null) {
                data.error = this.error;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.error.length)
                writer.writeString(1, this.error);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Error {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Error();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.error = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Error {
            return Error.deserialize(bytes);
        }
    }
    export class Limit extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            limit?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("limit" in data && data.limit != undefined) {
                    this.limit = data.limit;
                }
            }
        }
        get limit() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set limit(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            limit?: number;
        }): Limit {
            const message = new Limit({});
            if (data.limit != null) {
                message.limit = data.limit;
            }
            return message;
        }
        toObject() {
            const data: {
                limit?: number;
            } = {};
            if (this.limit != null) {
                data.limit = this.limit;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.limit != 0)
                writer.writeInt32(1, this.limit);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Limit {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Limit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.limit = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Limit {
            return Limit.deserialize(bytes);
        }
    }
    export class Conflict extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transaction_id?: string;
            conflicting_transaction?: string;
            reason?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction_id" in data && data.transaction_id != undefined) {
                    this.transaction_id = data.transaction_id;
                }
                if ("conflicting_transaction" in data && data.conflicting_transaction != undefined) {
                    this.conflicting_transaction = data.conflicting_transaction;
                }
                if ("reason" in data && data.reason != undefined) {
                    this.reason = data.reason;
                }
            }
        }
        get transaction_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set transaction_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get conflicting_transaction() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set conflicting_transaction(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get reason() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set reason(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            transaction_id?: string;
            conflicting_transaction?: string;
            reason?: string;
        }): Conflict {
            const message = new Conflict({});
            if (data.transaction_id != null) {
                message.transaction_id = data.transaction_id;
            }
            if (data.conflicting_transaction != null) {
                message.conflicting_transaction = data.conflicting_transaction;
            }
            if (data.reason != null) {
                message.reason = data.reason;
            }
            return message;
        }
        toObject() {
            const data: {
                transaction_id?: string;
                conflicting_transaction?: string;
                reason?: string;
            } = {};
            if (this.transaction_id != null) {
                data.transaction_id = this.transaction_id;
            }
            if (this.conflicting_transaction != null) {
                data.conflicting_transaction = this.conflicting_transaction;
            }
            if (this.reason != null) {
                data.reason = this.reason;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transaction_id.length)
                writer.writeString(1, this.transaction_id);
            if (this.conflicting_transaction.length)
                writer.writeString(2, this.conflicting_transaction);
            if (this.reason.length)
                writer.writeString(3, this.reason);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Conflict {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Conflict();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.transaction_id = reader.readString();
                        break;
                    case 2:
                        message.conflicting_transaction = reader.readString();
                        break;
                    case 3:
                        message.reason = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Conflict {
            return Conflict.deserialize(bytes);
        }
    }
    export class SyncEvent extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            timestamp?: string;
            status?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
            }
        }
        get timestamp() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set timestamp(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set status(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            timestamp?: string;
            status?: string;
        }): SyncEvent {
            const message = new SyncEvent({});
            if (data.timestamp != null) {
                message.timestamp = data.timestamp;
            }
            if (data.status != null) {
                message.status = data.status;
            }
            return message;
        }
        toObject() {
            const data: {
                timestamp?: string;
                status?: string;
            } = {};
            if (this.timestamp != null) {
                data.timestamp = this.timestamp;
            }
            if (this.status != null) {
                data.status = this.status;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.timestamp.length)
                writer.writeString(1, this.timestamp);
            if (this.status.length)
                writer.writeString(2, this.status);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SyncEvent {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SyncEvent();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.timestamp = reader.readString();
                        break;
                    case 2:
                        message.status = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SyncEvent {
            return SyncEvent.deserialize(bytes);
        }
    }
    export class SyncStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            status?: string;
            progress?: number;
            errors?: Error[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
                if ("progress" in data && data.progress != undefined) {
                    this.progress = data.progress;
                }
                if ("errors" in data && data.errors != undefined) {
                    this.errors = data.errors;
                }
            }
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set status(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get progress() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set progress(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get errors() {
            return pb_1.Message.getRepeatedWrapperField(this, Error, 3) as Error[];
        }
        set errors(value: Error[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            status?: string;
            progress?: number;
            errors?: ReturnType<typeof Error.prototype.toObject>[];
        }): SyncStatus {
            const message = new SyncStatus({});
            if (data.status != null) {
                message.status = data.status;
            }
            if (data.progress != null) {
                message.progress = data.progress;
            }
            if (data.errors != null) {
                message.errors = data.errors.map(item => Error.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                status?: string;
                progress?: number;
                errors?: ReturnType<typeof Error.prototype.toObject>[];
            } = {};
            if (this.status != null) {
                data.status = this.status;
            }
            if (this.progress != null) {
                data.progress = this.progress;
            }
            if (this.errors != null) {
                data.errors = this.errors.map((item: Error) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.status.length)
                writer.writeString(1, this.status);
            if (this.progress != 0)
                writer.writeInt32(2, this.progress);
            if (this.errors.length)
                writer.writeRepeatedMessage(3, this.errors, (item: Error) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SyncStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SyncStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.status = reader.readString();
                        break;
                    case 2:
                        message.progress = reader.readInt32();
                        break;
                    case 3:
                        reader.readMessage(message.errors, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Error.deserialize(reader), Error));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SyncStatus {
            return SyncStatus.deserialize(bytes);
        }
    }
    export class ConflictResolver extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transaction_id?: string;
            resolution_strategy?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction_id" in data && data.transaction_id != undefined) {
                    this.transaction_id = data.transaction_id;
                }
                if ("resolution_strategy" in data && data.resolution_strategy != undefined) {
                    this.resolution_strategy = data.resolution_strategy;
                }
            }
        }
        get transaction_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set transaction_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get resolution_strategy() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set resolution_strategy(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            transaction_id?: string;
            resolution_strategy?: string;
        }): ConflictResolver {
            const message = new ConflictResolver({});
            if (data.transaction_id != null) {
                message.transaction_id = data.transaction_id;
            }
            if (data.resolution_strategy != null) {
                message.resolution_strategy = data.resolution_strategy;
            }
            return message;
        }
        toObject() {
            const data: {
                transaction_id?: string;
                resolution_strategy?: string;
            } = {};
            if (this.transaction_id != null) {
                data.transaction_id = this.transaction_id;
            }
            if (this.resolution_strategy != null) {
                data.resolution_strategy = this.resolution_strategy;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transaction_id.length)
                writer.writeString(1, this.transaction_id);
            if (this.resolution_strategy.length)
                writer.writeString(2, this.resolution_strategy);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConflictResolver {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConflictResolver();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.transaction_id = reader.readString();
                        break;
                    case 2:
                        message.resolution_strategy = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ConflictResolver {
            return ConflictResolver.deserialize(bytes);
        }
    }
    export class ConflictList extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            conflict_list?: Conflict[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("conflict_list" in data && data.conflict_list != undefined) {
                    this.conflict_list = data.conflict_list;
                }
            }
        }
        get conflict_list() {
            return pb_1.Message.getRepeatedWrapperField(this, Conflict, 1) as Conflict[];
        }
        set conflict_list(value: Conflict[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            conflict_list?: ReturnType<typeof Conflict.prototype.toObject>[];
        }): ConflictList {
            const message = new ConflictList({});
            if (data.conflict_list != null) {
                message.conflict_list = data.conflict_list.map(item => Conflict.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                conflict_list?: ReturnType<typeof Conflict.prototype.toObject>[];
            } = {};
            if (this.conflict_list != null) {
                data.conflict_list = this.conflict_list.map((item: Conflict) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.conflict_list.length)
                writer.writeRepeatedMessage(1, this.conflict_list, (item: Conflict) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConflictList {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConflictList();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.conflict_list, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Conflict.deserialize(reader), Conflict));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ConflictList {
            return ConflictList.deserialize(bytes);
        }
    }
    export class SyncEventList extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            sync_list?: SyncEvent[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sync_list" in data && data.sync_list != undefined) {
                    this.sync_list = data.sync_list;
                }
            }
        }
        get sync_list() {
            return pb_1.Message.getRepeatedWrapperField(this, SyncEvent, 1) as SyncEvent[];
        }
        set sync_list(value: SyncEvent[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            sync_list?: ReturnType<typeof SyncEvent.prototype.toObject>[];
        }): SyncEventList {
            const message = new SyncEventList({});
            if (data.sync_list != null) {
                message.sync_list = data.sync_list.map(item => SyncEvent.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                sync_list?: ReturnType<typeof SyncEvent.prototype.toObject>[];
            } = {};
            if (this.sync_list != null) {
                data.sync_list = this.sync_list.map((item: SyncEvent) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.sync_list.length)
                writer.writeRepeatedMessage(1, this.sync_list, (item: SyncEvent) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SyncEventList {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SyncEventList();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.sync_list, () => pb_1.Message.addToRepeatedWrapperField(message, 1, SyncEvent.deserialize(reader), SyncEvent));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SyncEventList {
            return SyncEventList.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedIndexSynchroService {
        static definition = {
            SyncLedger: {
                path: "/sync.IndexSynchro/SyncLedger",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Null) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Null.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Status) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Status.deserialize(new Uint8Array(bytes))
            },
            DetectLedgerConflicts: {
                path: "/sync.IndexSynchro/DetectLedgerConflicts",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Null) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Null.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: ConflictList) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => ConflictList.deserialize(new Uint8Array(bytes))
            },
            ResolveLedgerConflict: {
                path: "/sync.IndexSynchro/ResolveLedgerConflict",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: ConflictResolver) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => ConflictResolver.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Status) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Status.deserialize(new Uint8Array(bytes))
            },
            BroadcastTransaction: {
                path: "/sync.IndexSynchro/BroadcastTransaction",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: TransactionId) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => TransactionId.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Status) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Status.deserialize(new Uint8Array(bytes))
            },
            FetchMissingTransactions: {
                path: "/sync.IndexSynchro/FetchMissingTransactions",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Null) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Null.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: TransactionIdList) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => TransactionIdList.deserialize(new Uint8Array(bytes))
            },
            MonitorLedgerSyncStatus: {
                path: "/sync.IndexSynchro/MonitorLedgerSyncStatus",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Null) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Null.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: SyncStatus) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => SyncStatus.deserialize(new Uint8Array(bytes))
            },
            ForceLedgerReconciliation: {
                path: "/sync.IndexSynchro/ForceLedgerReconciliation",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Null) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Null.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Status) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Status.deserialize(new Uint8Array(bytes))
            },
            SetLedgerConflictResolutionStrategy: {
                path: "/sync.IndexSynchro/SetLedgerConflictResolutionStrategy",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Strategy) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Strategy.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Status) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Status.deserialize(new Uint8Array(bytes))
            },
            ScheduleLedgerSync: {
                path: "/sync.IndexSynchro/ScheduleLedgerSync",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Interval) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Interval.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: Status) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => Status.deserialize(new Uint8Array(bytes))
            },
            ViewLedgerSyncHistory: {
                path: "/sync.IndexSynchro/ViewLedgerSyncHistory",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: Limit) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => Limit.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: SyncEventList) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => SyncEventList.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract SyncLedger(call: grpc_1.ServerUnaryCall<Null, Status>, callback: grpc_1.sendUnaryData<Status>): void;
        abstract DetectLedgerConflicts(call: grpc_1.ServerUnaryCall<Null, ConflictList>, callback: grpc_1.sendUnaryData<ConflictList>): void;
        abstract ResolveLedgerConflict(call: grpc_1.ServerUnaryCall<ConflictResolver, Status>, callback: grpc_1.sendUnaryData<Status>): void;
        abstract BroadcastTransaction(call: grpc_1.ServerUnaryCall<TransactionId, Status>, callback: grpc_1.sendUnaryData<Status>): void;
        abstract FetchMissingTransactions(call: grpc_1.ServerUnaryCall<Null, TransactionIdList>, callback: grpc_1.sendUnaryData<TransactionIdList>): void;
        abstract MonitorLedgerSyncStatus(call: grpc_1.ServerUnaryCall<Null, SyncStatus>, callback: grpc_1.sendUnaryData<SyncStatus>): void;
        abstract ForceLedgerReconciliation(call: grpc_1.ServerUnaryCall<Null, Status>, callback: grpc_1.sendUnaryData<Status>): void;
        abstract SetLedgerConflictResolutionStrategy(call: grpc_1.ServerUnaryCall<Strategy, Status>, callback: grpc_1.sendUnaryData<Status>): void;
        abstract ScheduleLedgerSync(call: grpc_1.ServerUnaryCall<Interval, Status>, callback: grpc_1.sendUnaryData<Status>): void;
        abstract ViewLedgerSyncHistory(call: grpc_1.ServerUnaryCall<Limit, SyncEventList>, callback: grpc_1.sendUnaryData<SyncEventList>): void;
    }
    export class IndexSynchroClient extends grpc_1.makeGenericClientConstructor(UnimplementedIndexSynchroService.definition, "IndexSynchro", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        SyncLedger: GrpcUnaryServiceInterface<Null, Status> = (message: Null, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Status>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Status>, callback?: grpc_1.requestCallback<Status>): grpc_1.ClientUnaryCall => {
            return super.SyncLedger(message, metadata, options, callback);
        };
        DetectLedgerConflicts: GrpcUnaryServiceInterface<Null, ConflictList> = (message: Null, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<ConflictList>, options?: grpc_1.CallOptions | grpc_1.requestCallback<ConflictList>, callback?: grpc_1.requestCallback<ConflictList>): grpc_1.ClientUnaryCall => {
            return super.DetectLedgerConflicts(message, metadata, options, callback);
        };
        ResolveLedgerConflict: GrpcUnaryServiceInterface<ConflictResolver, Status> = (message: ConflictResolver, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Status>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Status>, callback?: grpc_1.requestCallback<Status>): grpc_1.ClientUnaryCall => {
            return super.ResolveLedgerConflict(message, metadata, options, callback);
        };
        BroadcastTransaction: GrpcUnaryServiceInterface<TransactionId, Status> = (message: TransactionId, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Status>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Status>, callback?: grpc_1.requestCallback<Status>): grpc_1.ClientUnaryCall => {
            return super.BroadcastTransaction(message, metadata, options, callback);
        };
        FetchMissingTransactions: GrpcUnaryServiceInterface<Null, TransactionIdList> = (message: Null, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<TransactionIdList>, options?: grpc_1.CallOptions | grpc_1.requestCallback<TransactionIdList>, callback?: grpc_1.requestCallback<TransactionIdList>): grpc_1.ClientUnaryCall => {
            return super.FetchMissingTransactions(message, metadata, options, callback);
        };
        MonitorLedgerSyncStatus: GrpcUnaryServiceInterface<Null, SyncStatus> = (message: Null, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<SyncStatus>, options?: grpc_1.CallOptions | grpc_1.requestCallback<SyncStatus>, callback?: grpc_1.requestCallback<SyncStatus>): grpc_1.ClientUnaryCall => {
            return super.MonitorLedgerSyncStatus(message, metadata, options, callback);
        };
        ForceLedgerReconciliation: GrpcUnaryServiceInterface<Null, Status> = (message: Null, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Status>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Status>, callback?: grpc_1.requestCallback<Status>): grpc_1.ClientUnaryCall => {
            return super.ForceLedgerReconciliation(message, metadata, options, callback);
        };
        SetLedgerConflictResolutionStrategy: GrpcUnaryServiceInterface<Strategy, Status> = (message: Strategy, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Status>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Status>, callback?: grpc_1.requestCallback<Status>): grpc_1.ClientUnaryCall => {
            return super.SetLedgerConflictResolutionStrategy(message, metadata, options, callback);
        };
        ScheduleLedgerSync: GrpcUnaryServiceInterface<Interval, Status> = (message: Interval, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Status>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Status>, callback?: grpc_1.requestCallback<Status>): grpc_1.ClientUnaryCall => {
            return super.ScheduleLedgerSync(message, metadata, options, callback);
        };
        ViewLedgerSyncHistory: GrpcUnaryServiceInterface<Limit, SyncEventList> = (message: Limit, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<SyncEventList>, options?: grpc_1.CallOptions | grpc_1.requestCallback<SyncEventList>, callback?: grpc_1.requestCallback<SyncEventList>): grpc_1.ClientUnaryCall => {
            return super.ViewLedgerSyncHistory(message, metadata, options, callback);
        };
    }
}
